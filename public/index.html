<!DOCTYPE html>
<html>
<head>
    <title>Super Cool</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="style.css">
    <link href="https://fonts.googleapis.com/css?family=Righteous" rel="stylesheet">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script type="text/javascript" src="render_engine.js"></script>
    <script type="text/javascript" src="api_comm.js"></script>
</head>
<body>
    <div class="header">
        <h>SUPER COOL</h>
        <div class="count" id="countBox" style="display: none"><h>Player Count: <span id="playerCount">1</span></h></div>
    </div>
    <div class="main-body">
        <div id="login_screen" style="display: block">
            <div class="screen-body">
                <div><h class="title-logo">SUPER COOL</h></div>
                <div><input id="nameInput" type="text" class="login-input" placeholder="ENTER NAME"/></div>
                <div class="button" id="joinButton">JOIN</div>
            </div>
        </div>
        <canvas id="game_screen" width="1280" height="720" style="display: none"></canvas>
    </div>
    <div>
        <div class="button" id="moveButton">MOVE</div>
        <div class="button" id="shootButton">FIRE</div>
    </div>
    <script>
        (function() {
            let gamestate = {};

            let current_update_time = -1;
            let current_player_update_time = -1;
            let player = new Player();
            let api_comm = new APIComm();
            let render = new RenderEngine();
            let move_line = new MouseLine();
            let shoot_line = new MouseLine();
            shoot_line.color = SHOOT_COLOR;
            shoot_line.is_scaled = false;

            let disableLines = function() {
                move_line.is_visible = false;
                move_line.is_enabled = false;
                shoot_line.is_visible = false;
                shoot_line.is_enabled = false;
            };

            render.canvas.addEventListener('mousemove', function(evt) {
                let rect = render.canvas.getBoundingClientRect(); // need to use this every update since scroll changes it

                if(move_line.is_enabled) {
                    move_line.setStart(player.x, player.y);
                    move_line.x = evt.clientX - rect.left;
                    move_line.y = evt.clientY - rect.top;
                }
                if(shoot_line.is_enabled) {
                    shoot_line.setStart(player.x, player.y);
                    shoot_line.x = evt.clientX - rect.left;
                    shoot_line.y = evt.clientY - rect.top;
                }
            });

            render.canvas.addEventListener('mouseup', function(evt) {
                if(move_line.is_visible && move_line.is_enabled) {
                    move_line.is_enabled = false;
                }
                if(shoot_line.is_visible && shoot_line.is_enabled) {
                    shoot_line.is_enabled = false;
                }
                if(shoot_line.is_visible && move_line.is_visible) {
                    let limited = move_line.getLimitedMousePos();
                    let mdx = limited.x-move_line.start_x;
                    let mdy = limited.y-move_line.start_y;
                    let move_angle = Math.atan2(mdy, mdx);
                    let shoot_angle = Math.atan2(shoot_line.y-shoot_line.start_y, shoot_line.x-shoot_line.start_x);

                    api_comm.sendPlayerAction(player.entityId, { angle: move_angle, magnitude: Math.sqrt(mdx*mdx + mdy*mdy)}, { angle: shoot_angle });
                }
            });

            document.getElementById('moveButton').addEventListener('mouseup', function() {
                move_line.setStart(player.x, player.y);
                if(shoot_line.is_enabled && shoot_line.is_visible) {
                    shoot_line.is_visible = false;
                    shoot_line.is_enabled = false;
                }
                move_line.is_visible = true;
                move_line.is_enabled = true;
            });

            document.getElementById('shootButton').addEventListener('mouseup', function() {
                shoot_line.setStart(player.x, player.y);
                if(move_line.is_enabled && move_line.is_visible) {
                    move_line.is_visible = false;
                    move_line.is_enabled = false;
                }
                shoot_line.is_visible = true;
                shoot_line.is_enabled = true;
            });

//            document.getElementById('playButton').addEventListener('mouseup', function() {
//                disableLines();
//
//                let limited = move_line.getLimitedMousePos();
//                player.vx = limited.x-player.x;
//                player.vy = limited.y-player.y;
//
//                let bullet = new Laser();
//                let angle = Math.atan2(shoot_line.y-shoot_line.start_y, shoot_line.x-shoot_line.start_x);
//                bullet.x = player.x;
//                bullet.y = player.y;
//                bullet.setDirection(angle);
//                render.add(bullet);
//                render.play();
//            });

            document.getElementById('joinButton').addEventListener('mouseup', function() {
                let name = document.getElementById('nameInput').value;
                api_comm.sendPlayerLogin(name, (data) => {
                    player.entityId = data.playerId;
                    console.log("Joined Session! id: " + player.entityId);

                    api_comm.getGameState((data) => {
                        gamestate = data;

                        render.add(shoot_line);
                        render.add(move_line);

                        render.resetPlayers(data.players, player);
                        render.start();

                        document.getElementById('login_screen').setAttribute("style", "display: none");
                        document.getElementById('game_screen').setAttribute("style", "display: block");
                        document.getElementById('countBox').setAttribute("style", "display: inline-block");
                    });
                });
            });

            window.setInterval(()=>{
                api_comm.getHeartBeat((data) => {
                    if(current_update_time == -1) {
                        current_update_time = data.readyTimeStamp;
                        current_player_update_time = data.newPlayerTimeStamp;
                    } else if(current_update_time < data.readyTimeStamp) {
                        current_update_time = data.readyTimeStamp;
                        api_comm.getGameState((data) => {
                            console.log(data);
                            render.updateEntities(gamestate, data);
                            gamestate = data;
                            render.onAnimateDone(() => {
                                render.players.forEach((player) => {
                                    data.players.forEach((new_player) => {
                                        if(player.entityId == new_player.entityId) {
                                            player.x = new_player.x;
                                            player.y = new_player.y;
                                        }
                                    });
                                });
                                data.lasers.forEach((laser) => {
                                    render.entities.forEach((ent) => {
                                        if(ent.type == 'laser' && ent.entityId == laser.entityId) {
                                            ent.x = laser.x;
                                            ent.y = laser.y;
                                        }
                                    });
                                });
                            });
                            disableLines();
                            render.play();
                            document.getElementById('playerCount').innerHTML = gamestate.players.length;
                        });
                    } else if(current_player_update_time < data.newPlayerTimeStamp) {
                        current_player_update_time = data.newPlayerTimeStamp;
                        api_comm.getGameState((data) => {
                            gamestate = data;
                            render.resetPlayers(data.players, player);
                            document.getElementById('playerCount').innerHTML = gamestate.players.length;
                        });
                    }
                });
            }, 500);
        })();
    </script>
</body>
</html>